// Generated by CoffeeScript 1.6.3
var actions, altEnv, argsHint, colors, compile, deferred, doAction, env, environment, input, inspector, keypress, kids, lib, lstatSync, mocha, normalize, primaryTabComplete, program, prompt, readFileSync, readdirSync, refresh, run, secondaryTabComplete, sep, shutdown, spawn, spec, src, test, watch, watcher, _ref, _ref1,
  __slice = [].slice;

deferred = require('also').deferred;

watcher = require('./watcher').watcher;

environment = require('./environment').environment;

inspector = require('./inspector').inspector;

_ref = require('fs'), readFileSync = _ref.readFileSync, readdirSync = _ref.readdirSync, lstatSync = _ref.lstatSync;

normalize = require('path').normalize;

spawn = require('child_process').spawn;

sep = require('path').sep;

compile = require('coffee-script').compile;

colors = require('colors');

program = require('commander');

keypress = require('keypress');

keypress(process.stdin);

program.version(JSON.parse(readFileSync(__dirname + '/../package.json'), 'utf8').version);

program.option('-w, --no-watch', 'Dont watch spec and src dirs.');

program.option('-n, --no-env', 'Dont load .env.test');

program.option('-m, --mocha', 'Use mocha.');

program.option('-e, --alt-env [name]', 'Loads .env.name');

program.option('    --spec    [dir]', 'Specify alternate spec dir.', 'spec');

program.option('    --src     [dir]', 'Specify alternate src dir.', 'src');

program.option('    --lib     [dir]', 'Specify alternate compile target.', 'lib');

_ref1 = program.parse(process.argv), env = _ref1.env, altEnv = _ref1.altEnv, mocha = _ref1.mocha, watch = _ref1.watch, spec = _ref1.spec, src = _ref1.src, lib = _ref1.lib, env = _ref1.env;

kids = [];

test = deferred(function(_arg, file) {
  var args, bin, ipsoPath, resolve, running;
  resolve = _arg.resolve;
  if (!file.split('.').pop().match(/^js$|coffee$/)) {
    console.log('\nipso: ' + ("ignored " + file).grey);
    resolve();
    return;
  }
  if (!mocha) {
    console.log('\nipso: ' + "Unspecified spec scaffold.".red, "ipso --mocha");
    resolve();
    return;
  }
  ipsoPath = normalize(__dirname + '/ipso');
  bin = normalize(__dirname + '/../node_modules/.bin/mocha');
  args = ['--colors', '--compilers', 'coffee:coffee-script', '--require', 'should', file];
  console.log('\nipso: ' + ("node_modules/.bin/mocha " + (args.join(' '))).grey);
  process.env.IPSO_SRC = src;
  running = spawn(bin, args, {
    stdio: 'inherit'
  });
  return running.on('exit', resolve);
});

compile = deferred(function(_arg) {
  var args, bin, resolve, running;
  resolve = _arg.resolve;
  bin = normalize(__dirname + '/../node_modules/.bin/coffee');
  args = ['-c', '-b', '-o', lib, src];
  console.log('\nipso: ' + ("node_modules/.bin/coffee " + (args.join(' '))).grey);
  running = spawn(bin, args, {
    stdio: 'inherit'
  });
  return running.on('exit', resolve);
});

if (env || typeof altEnv === 'string') {
  environment(altEnv);
}

if (watch) {
  watcher({
    path: program.spec || 'spec',
    handler: {
      change: function(file, stats) {
        return test(file).then(function() {
          return refresh();
        });
      }
    }
  });
  watcher({
    path: program.src || 'src',
    handler: {
      change: function(file, stats) {
        if (!file.match(/\.coffee/)) {
          return;
        }
        return compile().then(function() {
          var specFile;
          refresh();
          specFile = file.replace(/\.coffee$/, '_spec.coffee');
          specFile = specFile.replace(process.cwd() + sep + src, spec);
          return test(specFile);
        }).then(function() {
          return refresh();
        });
      }
    }
  });
}

prompt = '> ';

input = '';

argsHint = '';

actions = {
  'inspect': {
    args: '  [<web-port>, <debug-port>] <script>',
    secondary: 'pathWalker'
  }
};

primaryTabComplete = function() {
  var action, matches;
  matches = [];
  for (action in actions) {
    if (action.match(new RegExp("^" + input))) {
      matches.push(action);
    }
  }
  if (matches.length === 0) {
    input = '';
    return primaryTabComplete();
  }
  return matches;
};

secondaryTabComplete = function(act) {
  var all, file, files, last, part, parts, path, secondaryType, select, stat, _i, _len;
  try {
    secondaryType = actions[act].secondary;
  } catch (_error) {}
  if (!secondaryType) {
    return [];
  }
  if (secondaryType === 'pathWalker') {
    try {
      all = input.split(' ').pop();
    } catch (_error) {}
    parts = all.split(sep);
    last = parts.pop();
    path = process.cwd() + sep + parts.join(sep) + sep;
    files = readdirSync(path);
    select = files.filter(function(file) {
      return file.match(new RegExp("^" + last));
    });
    if (select.length === 1) {
      input += select[0].slice(last.length);
      file = input.split(' ').pop();
      stat = lstatSync(process.cwd() + sep + file);
      if (stat.isDirectory()) {
        input += sep;
      }
    } else {
      console.log();
      for (_i = 0, _len = select.length; _i < _len; _i++) {
        part = select[_i];
        stat = lstatSync(path + part);
        if (stat.isDirectory()) {
          console.log(part + sep);
        } else {
          console.log(part);
        }
      }
    }
    return [];
  }
};

refresh = function(output, stream) {
  if (output != null) {
    switch (stream) {
      case 'stderr':
        process.stdout.write(output.red);
        break;
      default:
        process.stdout.write(output);
    }
  }
  input = input.replace('  ', ' ');
  process.stdout.clearLine();
  process.stdout.cursorTo(0);
  process.stdout.write(prompt + input + argsHint);
  return process.stdout.cursorTo((prompt + input).length);
};

shutdown = function(code) {
  var kid, _i, _len;
  for (_i = 0, _len = kids.length; _i < _len; _i++) {
    kid = kids[_i];
    kid.kill();
  }
  return process.exit(code);
};

doAction = function() {
  var act, args, trimmed, _ref2;
  if (input === '') {
    return;
  }
  _ref2 = input.split(' '), act = _ref2[0], args = 2 <= _ref2.length ? __slice.call(_ref2, 1) : [];
  trimmed = args.filter(function(arg) {
    return arg !== '';
  });
  input = '';
  switch (act) {
    case 'inspect':
      return inspector({
        args: args
      }, kids, refresh);
    default:
      if (act != null) {
        return console.log({
          action: act,
          args: trimmed
        });
      }
  }
};

run = function() {
  var stdin;
  stdin = process.openStdin();
  process.stdin.setRawMode(true);
  refresh();
  return process.stdin.on('keypress', function(chunk, key) {
    var act, action, ctrl, m, matches, meta, name, sequence, shift, _i, _len, _ref2;
    argsHint = '';
    try {
      name = key.name, ctrl = key.ctrl, meta = key.meta, shift = key.shift, sequence = key.sequence;
    } catch (_error) {}
    if (ctrl) {
      switch (name) {
        case 'd':
          shutdown(0);
          break;
        case 'c':
          input = '';
          refresh();
      }
      return;
    }
    if (name === 'backspace') {
      input = input.slice(0, -1);
      return refresh();
    }
    if (name === 'tab') {
      try {
        _ref2 = input.match(/^(.*?)\s/), m = _ref2[0], act = _ref2[1];
      } catch (_error) {}
      if (act != null) {
        matches = secondaryTabComplete(act);
      } else {
        matches = primaryTabComplete();
      }
      if (matches.length === 1) {
        input = matches[0];
        argsHint = ' ' + actions[matches[0]].args.grey;
        return refresh();
      } else {
        console.log();
        for (_i = 0, _len = matches.length; _i < _len; _i++) {
          action = matches[_i];
          console.log(action, actions[action].args.grey);
        }
        return refresh();
      }
    }
    if (name === 'return') {
      process.stdout.write('\n');
      doAction();
      process.stdout.write(prompt + input);
      return;
    }
    if (!chunk) {
      return;
    }
    input += chunk.toString();
    return refresh();
  });
};

run();
